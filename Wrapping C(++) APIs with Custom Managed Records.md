# Обертывание C(++) API с помощью настраиваемых управляемых записей

[Ссылка на оригинал:](https://blog.grijjy.com/2020/07/20/wrapping-c-apis-with-custom-managed-records)
 [Erik van Bilsen](https://blog.grijjy.com/author/erikvanbilsen)

В Delphi 10.4 появились пользовательские управляемые записи (Custom Managed Records). В этой статье мы покажем, как использовать эту новую языковую функцию для обёртывания сторонних API C(++) в простую модель. Мы также сравним этот метод с другими способами взаимодействия с C(++), которые вы, возможно, использовали ранее.

## Способы взаимодействия с C(++)

В рамках данного обсуждения мы предполагаем, что API C(++), которое вы хотите обернуть, следует некой модели «создание-использование-уничтожение». Здесь термин «объект» может означать объект C++ или любую форму структуры, используемую в C. Многие внешние API используют эту модель. Например, в API Windows есть такие функции, как `CreateWindow`, `ShowWindow` и `DestroyWindow`. Далее мы будем использовать термин «API C», даже если библиотека написана на C++ (поскольку нам в конечном итоге нужно взаимодействовать с простыми функциями C).

### 1. Использование классов

Существует несколько способов обернуть C-API. Традиционно для этого используются классы Delphi. VCL — яркий пример; большинство классов VCL представляют собой обёртки для дескрипторов в Windows API.

Распространённый шаблон проектирования здесь — создание дескриптора в конструкторе обёртки и его уничтожение в деструкторе. После этого дескриптор может использоваться другими методами и свойствами:

```pascal
type
  TFoo = class
  private
    FHandle: THandle;
  public
    constructor Create;
    destructor Destroy;
    function Calc(const ALeft, ARight: Integer): Integer;
  end;

constructor TFoo.Create;
begin
  inherited;
  FHandle := foo_create();
end;

destructor TFoo.Destroy;
begin
  foo_destroy(FHandle);
  inherited;
end;

function TFoo.Calc(const ALeft, ARight: Integer): Integer;
begin
  Result := foo_calc(FHandle, ALeft, ARight);
end;
```

Здесь процедуры, начинающиеся с `foo_`префикса « », реализованы в библиотеке третьей части.

Однако с этим методом могут возникнуть некоторые сложности. Предположим, библиотека C хранит список «объектов» Bar для каждого объекта Foo. Мы бы обернули их в `TBar`класс в Delphi. Реализация могла бы выглядеть так:

```pascal
type
  TFoo = class
  public
    ...
    function GetItem(const AIndex: Integer): TBar;
  end;

function TFoo.GetItem(const AIndex: Integer): TBar;
begin
  var BarHandle := foo_get_item(FHandle, AIndex);
  Result := TBar.Create(BarHandle); // ??
end;
```

Выделенная строка (// ??) здесь проблемная. Мы получаем дескриптор объекта Bar из C API, и нам нужно `TBar`каким-то образом обернуть его в класс. Мы могли бы создать `TBar`экземпляр «на лету», как в этом примере. Однако этот экземпляр в какой-то момент должен быть уничтожен. В данном примере за это отвечает пользователь вашего класса-обёртки. Это возлагает бремя управления временем жизни на пользователя. А поскольку неочевидно, что вызываемый метод `GetItem`создаёт новый экземпляр, пользователь, вероятно, не уничтожит его, что приведёт к утечкам памяти.

Это проблема всех API C, которые возвращают ссылки на существующие объекты. Существует несколько решений этой проблемы. Например, `TFoo`класс может хранить список `TBar`объектов и синхронизировать его с API C. Тогда `GetItem`метод будет возвращать объект из этого списка вместо создания нового. При этом `TFoo`класс будет обеспечивать уничтожение объектов в нужное время. Однако, в зависимости от API, поддерживать этот список синхронизированным не всегда просто или возможно.

Другое возможное решение — использовать словари, которые сопоставляют дескрипторы C с их обёртками Delphi. В этом случае `GetItem`метод проверит, содержит ли словарь дескриптор Bar. Если да, он вернёт соответствующую обёртку Delphi. В противном случае он создаст её и добавит в словарь. Однако поддержание словаря в актуальном состоянии иногда может быть проблематичным.

Кроме того, при использовании ссылок на существующие объекты C, обёртка Delphi не владеет дескриптором и не должна уничтожать его в своём деструкторе. Эта ситуация часто обрабатывается с помощью флага, называемого `FOwnsHandle`или аналогичного:

```pascal
type
  TBar = class
  private
    FHandle: THandle;
    FOwnsHandle: Boolean;
  private
    constructor Create(const AHandle: THandle;
      const AOwnsHandle: Boolean);
  public
    destructor Destroy; override;
  end;

constructor TBar.Create(const AHandle: THandle;
  const AOwnsHandle: Boolean);
begin
  inherited Create;
  FHandle := AHandle;
  FOwnsHandle := AOwnsHandle;
end;

destructor TBar.Destroy;
begin
  if (FOwnsHandle) then
    bar_destroy(FHandle);
  inherited;
end;
```

Здесь конструктор делается закрытым, поскольку он должен использоваться только внутри модуля, объявляющего `TBar`тип.

### 2. Использование объектных интерфейсов

Многие из этих проблем можно избежать, используя интерфейсы объектов вместо классов. Это также упрощает управление жизненным циклом, поскольку вам (и, что ещё важнее, пользователям вашей обёртки) не нужно беспокоиться об уничтожении объектов в нужный момент.

Приведенную выше модель класса можно преобразовать с использованием объектных интерфейсов следующим образом:

```pascal
type
  IBar = interface
    { Various declarations... }
  end;

type
  IFoo = interface
    function GetItem(const AIndex: Integer): IBar;
  end;

type
  TBar = class(TInterfacedObject, IBar)
    { Similar to TBar shown earlier }
  end;

type
  TFoo = class(TInterfacedObject, IFoo)
  private
    FHandle: THandle;
  protected
    { IFoo }
    function GetItem(const AIndex: Integer): IBar;
  public
    constructor Create;
    destructor Destroy; override;
  end;

constructor TFoo.Create;
begin
  inherited;
  FHandle := foo_create;
end;

destructor TFoo.Destroy;
begin
  foo_destroy(FHandle);
  inherited;
end;

function TFoo.GetItem(const AIndex: Integer): IBar;
begin
  var BarHandle := foo_get_item(FHandle, AIndex);
  Result := TBar.Create(BarHandle, False);
end;
```

Здесь `TFoo.GetItem`метод возвращает вновь созданный `IBar`интерфейс (который не владеет дескриптором). Поскольку это интерфейс, он будет автоматически уничтожен после того, как пользователь завершит работу с ним. Классу не нужно `TFoo`поддерживать список или словарь экземпляров Bar (хотя он может это делать, чтобы избежать частого выделения `TBar`объектов, если это проблематично).

Однако есть и недостатки. Многие методы-обёртки очень малы и вызывают только соответствующие C API. Однако, поскольку эти методы реализованы в интерфейсах, их нельзя встроить. Более того, поскольку интерфейс по сути представляет собой таблицу виртуальных методов, все методы в интерфейсе также являются виртуальными, что приводит к дополнительному уровню косвенности при вызове метода. Это не очень удобно для кэширования, поскольку требует доступа к различным (вероятно, удалённым) областям памяти перед вызовом. Частое обращение к функции-обёртке может негативно сказаться на производительности.

Более того, как и в случае с классами, вы фактически оборачиваете объект (C) внутрь другого объекта (Delphi), что приводит к дополнительному динамическому выделению памяти. Создание большого количества (временных) объектов таким образом может привести к дополнительной фрагментации памяти и снижению производительности.

Наконец, использование интерфейсов требует больше кода, поскольку приходится писать объявление интерфейса и дублировать его в классе. Кроме того, необходимо синхронизировать объявления интерфейса и класса. Однако я считаю это незначительным недостатком по сравнению со всеми преимуществами интерфейсов.

### 3. Использование записей

Иногда API C подходит для обёртывания внутри простой записи Delphi. Таким образом, можно избежать динамического выделения памяти и встроить методы-обёртки. Однако в этом случае автоматическое управление ресурсами невозможно, поэтому обычно управление временем жизни объектов ложится на плечи пользователей обёртки.

В некоторых ситуациях этого можно избежать, если каждая запись принадлежит некоему «главному» классу или записи. Например, можно использовать стороннюю XML DOM-библиотеку, где каждый XML-узел или элемент представляет собой запись, принадлежащую главному документу, а главный документ управляет временем существования этих записей.

Однако для многих API это решение нецелесообразно.

### 4. Использование настраиваемых записей

Это подводит нас к основной цели этой статьи. В оставшейся части я покажу вам, как использовать Custom Managed Records для обёртки C API. Это позволяет избежать многих из упомянутых выше недостатков (хотя и у этого подхода есть свои недостатки, о которых мы поговорим в конце статьи).

Причина этой публикации в том, что я искал (лучший) способ обернуть [Skia Graphics API](https://translate.google.com/website?sl=auto&tl=ru&hl=ru&client=webapp&u=https://skia.org/) . Мы используем этот API в нашем продукте Lumicademy для обеспечения согласованного представления (векторной) графики на всех платформах. Раньше у нас была оболочка на основе интерфейса для этой библиотеки, которая работала довольно хорошо. Однако у неё есть некоторые из упомянутых выше недостатков, таких как частое выделение небольших объектов и невозможность встраивания вызовов методов. Поскольку Skia API недавно претерпел серьёзные изменения, я подумал, что сейчас самое время пересмотреть нашу модель и посмотреть, можно ли добиться лучших результатов.

## Индивидуально управляемые записи 101

Начнем с краткого введения в функцию Custom Managed Records для тех, кто еще не знаком с этой новой языковой функцией.

Управляемые записи (а не пользовательские) — не новость в Delphi. Они существуют с первой версии, хотя вы, вероятно, ещё не называли их так. Управляемая запись — это обычная запись, но с одним или несколькими полями управляемого типа. Управляемый тип — это тип, жизненный цикл которого управляется компилятором и средой выполнения Delphi (обычно посредством подсчёта ссылок), и включает строки, динамические массивы, интерфейсы объектов и другие управляемые записи.

> До Delphi 10.4 обычный объект также являлся управляемым типом при компиляции на платформах ARC (мобильных). Однако теперь, когда у нас есть единая модель управления памятью на всех платформах (ура!), это уже не так.

При объявлении управляемой записи Delphi добавляет код для управления её временем существования и обработки присвоения одной записи другой. Например, рассмотрим следующий код:

```pascal
type
  TSomeRecord = record
    S: String; // A managed field
  end;

procedure Something;
var
  A, B: TSomeRecord;
begin
  A.S := 'Foo';
  B := A;
end;
```

Компилятор Delphi фактически преобразует это в следующий код (это не совсем точно, но достаточно для демонстрационных целей):

```pascal
procedure Something;
var
  A, B: TSomeRecord;
begin
  InitializeRecord(A);
  try
    InitializeRecord(B);
    try
      A.S := 'Foo';
      CopyRecord(B, A);
    finally
      FinalizeRecord(B);
    end;
  finally
    FinalizeRecord(A);
  end;
end;
```

Здесь `InitializeRecord`инициализирует все управляемые поля в записи (то есть очищает строки, динамические массивы, интерфейсы и т. д.). Аналогично, `CopyRecord`копирует управляемые поля из одной записи в другую. Это происходит путём обновления счётчиков ссылок всех управляемых полей. Наконец, `FinalizeRecord`снова уменьшает эти счётчики ссылок, что может привести к освобождению управляемого поля, если его счётчик ссылок достигнет 0.

> Обратите внимание, что эти три процедуры используют RTTI для перечисления всех управляемых полей в записи, что может привести к небольшому снижению производительности. Хотя обычно это несущественно, об этом следует помнить, особенно если в записи много управляемых полей.

Пользовательская управляемая запись очень похожа на обычную управляемую запись, но вместо того, чтобы компилятор вставлял вызовы `InitializeRecord`, `CopyRecord`и `FinalizeRecord`, он вызывает новые операторы `Initialize`, `Assign` и `Finalize`записи. Эти операторы необходимо написать самостоятельно, отсюда и «Custom» в названии пользовательской управляемой записи. Сигнатуры этих методов выглядят следующим образом:

```pascal
type
  TFoo = record
  public
    class operator Initialize(out ADest: TFoo);
    class operator Finalize(var ADest: TFoo);
    class operator Assign(var ADest: TFoo;
      const [ref] ASrc: TFoo);
  end;
  ```

Поскольку компилятор обеспечивает вызов этих операторов в нужное время, Custom Managed Records идеально подходит для легковесного управления жизненным циклом ресурсов (и RAII). Один из очевидных вариантов использования — реализация умных указателей для поддержки автоматического управления памятью для обычных объектов. Уверен, что прямо сейчас разработчики на Delphi экспериментируют с этой функцией…

Но он также очень полезен для управления жизненным циклом обернутых объектов C(++).

## Упаковка объектов C(++) в пользовательские управляемые записи

Итак, мы наконец добрались до сути статьи: как использовать эту новую языковую возможность для обёртывания объектов C(++). В качестве реального примера я буду использовать библиотеку Skia. Skia предоставляет два типа объектов через свой "Си" API: объекты с подсчётом ссылок и объекты без подсчёта ссылок. Для них требуются два разных подхода.

### 1. Упаковка объектов C(++) с подсчетом ссылок

Если вам повезёт, то API Си, который вы оборачиваете, поддерживает подсчёт ссылок на свои объекты. (В настоящее время это становится всё более распространённым для API Cи). Мы можем воспользоваться этим для реализации нашей пользовательской управляемой записи. Примером служит класс SKImage в Skia, который мы оборачиваем следующим образом:

```pascal
type
  TSKImage = record
  private
    FHandle: THandle;
    function GetWidth: Integer; inline;
    ...
  private
    constructor Create(const AHandle: THandle;
      const AOwnsHandle: Boolean); overload;
  public
    class operator Initialize(out ADest: TSKImage);
    class operator Finalize(var ADest: TSKImage);
    class operator Assign(var ADest: TSKImage;
      const [ref] ASrc: TSKImage);
  public
    class function Create(...): TSKImage; overload; static;
    ...
    property Width: Integer read GetWidth;
    ...
  end;

class function TSKImage.Create(...): TSKImage;
begin
  var Handle := sk_image_new_raster(...);
  Result := TSKImage.Create(Handle, True);
end;

constructor TSKImage.Create(const AHandle: THandle;
  const AOwnsHandle: Boolean);
begin
  FHandle := AHandle;
  if (AHandle <> 0) and (not AOwnsHandle) then
    sk_refcnt_safe_ref(AHandle);
end;

class operator TSKImage.Initialize(out ADest: TSKImage);
begin
  ADest.FHandle := 0;
end;

class operator TSKImage.Finalize(var ADest: TSKImage);
begin
  if (ADest.FHandle <> 0) then
    sk_refcnt_safe_unref(ADest.FHandle);
end;

class operator TSKImage.Assign(var ADest: TSKImage;
  const [ref] ASrc: TSKImage);
begin
  if (ASrc.FHandle <> ADest.FHandle) then
  begin
    if (ADest.FHandle <> 0) then
      sk_refcnt_safe_unref(ADest.FHandle);

    ADest.FHandle := ASrc.FHandle;

    if (ADest.FHandle <> 0) then
      sk_refcnt_safe_ref(ADest.FHandle);
  end;
end;

function TSKImage.GetWidth: Integer;
begin
  Assert(FHandle <> 0);
  Result := sk_image_get_width(FHandle);
end;
```

Это шаблонный код для большинства обёрток, использующих подсчёт ссылок, предоставляемый библиотекой. Работает он так:

- Функция `Create`класса создает новый дескриптор для объекта изображения Skia и передает этот дескриптор конструктору (устанавливая значение , `AOwnsHandle`чтобы `True`указать, что обертка будет владеть дескриптором).
- Конструктор сохраняет дескриптор и использует небольшой приём, позволяющий избежать необходимости хранить поле FOwnsHandle: если параметр AOwnsHandle равен True, конструктор больше ничего не делает. В этом случае, когда обёртка выходит из области видимости, вызывается оператор Finalize, который уменьшает счётчик ссылок (что может привести к уничтожению лежащего в основе объекта C++). Однако, если параметр AOwnsHandle равен False, мы не хотим уменьшать счётчик ссылок в Finalize. Можно было бы сохранить этот флаг в поле FOwnsHandle и проверять его значение в Finalize. Тем не менее, существует решение, не требующее хранения такого флага: достаточно просто увеличить счётчик ссылок в конструкторе. Тогда, когда Finalize снова уменьшит счётчик ссылок, в итоге получится, что счётчик ссылок не изменился, и лежащий в основе объект C++ останется нетронутым.
- Оператор `Initialize`очень прост: он просто снимает ручку.
- Оператор `Finalize`не так уж и сложен: он просто вызывает API C для уменьшения счётчика ссылок (после проверки корректности дескриптора). Обратите внимание, что это может привести к уничтожению базового объекта C++, если счётчик ссылок достигнет 0.
- Оператор `Assign`немного сложнее, поскольку здесь нам нужно выполнить несколько действий. Во-первых, нам не нужно ничего делать, если две записи одинаковы (то есть являются оберткой одного и того же дескриптора). Во-вторых, следует учитывать, что запись, которой вы присваиваете значение, может уже быть оберткой другого объекта C++. В этом случае нам нужно уменьшить её счётчик ссылок, поскольку теперь она будет оберткой другого объекта. Затем мы можем назначить дескриптор и соответственно увеличить его счётчик ссылок.
- Наконец, большинство других методов могут быть довольно простыми и обычно просто вызывают базовый API C, как `GetWidth`показано в этом примере. В зависимости от того, как написан API C, перед вызовом API может потребоваться проверка корректности дескриптора. В этом примере я использую утверждение, но вы также можете вызвать исключение или использовать другой вид обработки ошибок.

Это фрагмент шаблонного кода, который вам придётся повторять для своих обёрток (хотя в некоторых ситуациях можно сократить объём кода с помощью дженериков). Но в результате получается очень лёгкая обёртка, которая вообще не использует динамическую память (по крайней мере, на стороне Delphi) и позволяет быстро встраивать методы (как `GetWidth`в примере).

И что немаловажно, пользователям вашей обёртки не нужно беспокоиться об уничтожении ресурсов. Это автоматически управляется компилятором и средой выполнения. С точки зрения пользователей, Custom Managed Record можно использовать как обычный класс, не беспокоясь об управлении временем жизни.

### 2. Объекты C(++) без подсчета ссылок

Если API C, которое вы оборачиваете, не поддерживает подсчёт ссылок, вам придётся реализовать это самостоятельно. Первым побуждением может быть добавление целочисленного поля счётчика ссылок в запись, а затем использование его в операторах `Initialize`, `Assign`и `Finalize`. Однако это не сработает, если вы разрешите присваивать одну запись другой. В этом случае у обеих копий будут собственные счётчики ссылок. Счётчик ссылок одной записи может достичь нуля (и уничтожить базовый объект C++), в то время как другая запись всё ещё будет иметь ссылку на неё.

Поэтому при назначении одной записи другой необходимо убедиться, что существует только один экземпляр поля счётчика ссылок. Решение, которое я использовал для обёртки Skia, заключается в хранении дескриптора, счётчика ссылок и некоторой другой информации внутри динамически выделяемой вспомогательной записи. Затем операторы `Initialize`, `Assign`и `Finalize`обёртки используют эту вспомогательную запись для управления временем существования обёрнутого дескриптора.

```pascal
  TSKSharedHandleDeleter = procedure(AHandle: THandle); cdecl;

  PSKSharedHandle = ^TSKSharedHandle;
  TSKSharedHandle = record
  private
    FHandle: THandle;
    FDeleter: TSKSharedHandleDeleter;
    [volatile] FRefCount: Integer;
    FOwnsHandle: Boolean;
  public
    class function Create(const AHandle: THandle; 
       const ADeleter: TSKSharedHandleDeleter;
       const AOwnsHandle: Boolean): PSKSharedHandle; static;
    procedure AddRef; inline;
    procedure Release; inline;
  end;

class function TSKSharedHandle.Create(const AHandle: THandle;
  const ADeleter: TSKSharedHandleDeleter;
  const AOwnsHandle: Boolean): PSKSharedHandle;
begin
  Assert(AHandle <> 0);
  Assert(Assigned(ADeleter));
  GetMem(Result, SizeOf(TSKSharedHandle));
  Result.FHandle := AHandle;
  Result.FDeleter := ADeleter;
  Result.FRefCount := 1;
  Result.FOwnsHandle := AOwnsHandle;
end;

procedure TSKSharedHandle.AddRef;
begin
  if (@Self <> nil) then
    AtomicIncrement(FRefCount);
end;

procedure TSKSharedHandle.Release;
begin
  if (@Self <> nil) and (AtomicDecrement(FRefCount) = 0) then
  begin
    if (FOwnsHandle) then
      FDeleter(FHandle);
    FreeMem(@Self);
  end;
end;
```

Это требует некоторых пояснений:

- Запись имеет 4 поля:
    - Обернутый Handle:.
    - API на языке C, который используется для освобождения дескриптора, когда счетчик ссылок достигает 0. В библиотеке Skia все API уничтожения объектов имеют одинаковую сигнатуру: `cdecl`процедуру с одним параметром, содержащую дескриптор объекта, который необходимо уничтожить.
    - Количество ссылок, которое мы используем для управления жизненным циклом.
    - Флаг, указывающий, владеем ли мы этим именем или нет.
- Функция `Create`класса выделяет экземпляр этой записи в куче. Она инициализирует все поля и устанавливает счётчик ссылок равным 1.
- Существует `AddRef`метод, который вызывается, когда нам нужно сохранить ссылку. Он просто увеличивает счётчик ссылок потокобезопасным способом. `if (@Self <> nil) then`Проверка « » добавлена, чтобы позволить вызывать этот метод для нулевого указателя. Это упрощает часть кода в дальнейшем. (Оператор `@`необходим, поскольку мы работаем с записью, а не с объектом.)
- Аналогично, этот `Release`метод используется для освобождения ссылки. Он уменьшает счётчик ссылок. Когда счётчик ссылок достигает нуля, он вызывает API языка C для уничтожения дескриптора и освобождения памяти, выделенной функцией `Create`.

Теперь мы можем использовать этот хелпер в наших обёртках Skia. Пример использования — класс SKCanvas. API Skia не предоставляет встроенного подсчёта ссылок для этого класса, поэтому мы делаем это самостоятельно с помощью `PSKSharedHandle`хелпера:

```pascal
type
  TSKCanvas = record
  private
    FShared: PSKSharedHandle;
  private
    constructor Create(const AHandle: THandle;
      const AOwnsHandle: Boolean); overload;
  public
    class operator Initialize(out ADest: TSKCanvas);
    class operator Finalize(var ADest: TSKCanvas);
    class operator Assign(var ADest: TSKCanvas;
      const [ref] ASrc: TSKCanvas);
  public
    class function Create(...): TSKCanvas; overload; static;

    procedure Clear; inline;
    ...
  end;

class function TSKCanvas.Create(...): TSKCanvas;
begin
  var Handle := sk_canvas_new_from_bitmap(...);
  Result := TSKCanvas.Create(Handle, True);
end;

constructor TSKCanvas.Create(const AHandle: THandle;
  const AOwnsHandle: Boolean);
begin
  if (AHandle = 0) then
    FShared := nil
  else
    FShared := TSKSharedHandle.Create(AHandle,
      sk_canvas_destroy, AOwnsHandle);
end;

class operator TSKCanvas.Initialize(out ADest: TSKCanvas);
begin
  ADest.FShared := nil;
end;

class operator TSKCanvas.Finalize(var ADest: TSKCanvas);
begin
  ADest.FShared.Release;
end;

class operator TSKCanvas.Assign(var ADest: TSKCanvas;
  const [ref] ASrc: TSKCanvas);
begin
  if (ADest.FShared <> ASrc.FShared) then
  begin
    ADest.FShared.Release;
    ADest.FShared := ASrc.FShared;
    ADest.FShared.AddRef;
  end;
end;

procedure TSKCanvas.Clear;
begin
  Assert(FShared <> nil);
  sk_canvas_clear(FShared.Handle);
end;
```

Это опять же по большей части шаблон:

- Вместо `FHandle`поля эта запись имеет `FShared`поле типа `PSKSharedHandle`. Это гарантирует, что все копии записи будут иметь `FShared`поле, указывающее на один и тот же базовый идентификатор и количество ссылок.
- Конструктор выделяет общий дескриптор. Он передаёт `sk_canvas_destroy`API C для этого общего дескриптора. Этот API будет вызван для уничтожения холста, когда все записи, использующие этот дескриптор, выйдут из области действия.
- Все остальные методы довольно просты. Единственное, о чём следует помнить, — это то, что `Assign`оператор может присваивать значение записи, которая уже является обёрткой другого объекта C++. Поэтому нам нужно выполнить операцию `Release`для старой обёртки и операцию `AddRef`для новой (помните, что эти методы можно безопасно вызывать для обёртки `nil`).

Этот способ обёртывания C++-объекта по-прежнему довольно лёгкий, хотя и требует динамического выделения памяти для `PSKSharedHandle`. Вы можете улучшить ситуацию, создав `PSKSharedHandle`пул, чтобы избежать повторного выделения небольших объёмов памяти.

> Некоторые API C позволяют хранить произвольные пользовательские данные (или теги) вместе с объектом. Это может пригодиться для хранения счётчика ссылок, поэтому вам не потребуется динамически выделяемый общий дескриптор.

## Что нужно иметь в виду

Все обсуждаемые здесь методы обёртки имеют некоторые оговорки. Например, как сравнивать две обёртки? Если бы вы обернули объекты C++ в классы или интерфейсы, то нельзя было бы просто написать « `if (Image1 = Image2) then...`». Это сравнило бы обёрнутые объекты Delphi друг с другом, а _не_ с их обёрнутыми дескрипторами. Вместо этого можно добавить `Equals`метод для сравнения их базовых дескрипторов (или переопределить его, `TObject.Equals`если вы используете классы для обёртки). Однако в этом случае пользователю обёртки приходится вызывать `Equals`оператор равенства, а не использовать его.

Однако с помощью Custom Managed Records вы можете перегрузить оператор равенства (и неравенства), что позволит вашим пользователям очень естественно сравнивать два объекта C++:
```pascal
type
  TSKImage = record
  private
    FHandle: THandle;
  public
    class operator Equal(const ALeft,
      ARight: TSKImage): Boolean; inline; static;
    class operator NotEqual(const ALeft,
      ARight: TSKImage): Boolean; inline; static;
  end;

class operator TSKImage.Equal(const ALeft,
  ARight: TSKImage): Boolean;
begin
  Result := (ALeft.FHandle = ARight.FHandle);
end;

class operator TSKImage.NotEqual(const ALeft,
  ARight: TSKImage): Boolean;
begin
  Result := (ALeft.FHandle <> ARight.FHandle);
end;
```
## Недостатки

Использование пользовательских управляемых записей для упаковки также имеет некоторые недостатки по сравнению с другими методами.

### 1. Сравнить с нулем

Преимущество использования классов или интерфейсов объектов заключается в том, что они могут `nil`указывать на отсутствие экземпляра. Однако записи нельзя `nil`сравнивать с `nil`. Поэтому нельзя написать что-то вроде « `if (Image <> nil) then...`». Эту проблему можно решить, добавив метод, например `IsNil`, который возвращает True, если базовый дескриптор равен 0. В обёртке Skia мы снова используем перегруженные операторы (не)равенства, поэтому сравнение выполняется `nil`более естественно:
```pascal
class operator TSKImage.Equal(const ALeft: TSKImage;
  const ARight: Pointer): Boolean;
begin
  Result := (Pointer(ALeft.FHandle) = ARight);
end;

class operator TSKImage.NotEqual(const ALeft: TSKImage;
  const ARight: Pointer): Boolean;
begin
  Result := (Pointer(ALeft.FHandle) <> ARight);
end;
```
Здесь правая часть операции — указатель, позволяющий сравнивать с `nil`.

### 2. Параметры по умолчанию

Однако это не будет работать, если вы разрешите `nil`параметры по умолчанию, поскольку у вас не может быть параметров по умолчанию для типов записей:
```pascal
procedure DrawButton(const ACaption: String;
  const AGlyph: TSKImage = nil); // Does NOT compile
```
Обычным решением этой проблемы является создание перегруженной версии:
```pascal
procedure DrawButton(const ACaption: String); overload;
procedure DrawButton(const ACaption: String;
  const AGlyph: TSKImage); overload;
```

### 3. Передача заявлений

Иногда у вас есть два типа классов C++, которые ссылаются друг на друга. При их обёртке в классы или интерфейсы Delphi можно использовать предварительные объявления, например:

```pascal
type
  TBar = class;

  TFoo = class
  public
    procedure Go(const ABar: TBar);
  end;

  TBar = class
  public
    procedure Go(const AFoo: TFoo);
  end;
```

Однако это невозможно сделать с записями (Custom Managed). Обойти эту проблему можно с помощью помощников записей:

```pascal
type
  TFoo = record
  public
    ...
  end;

type
  TBar = record
  public
    procedure Go(const AFoo: TFoo);
  end;

type
  _TFooHelper = record helper for TFoo
  public
    procedure Go(const ABar: TBar);
  end;
  ```

Это некрасиво, но работает.

> Обратите внимание, что я предпочитаю начинать имена записей и вспомогательных методов классов с подчеркивания (_), чтобы отговорить людей от непосредственного использования типа.

### 4. Наследование

Наконец, и это важный момент, вы не можете использовать наследование для записей. Если ваш C API использует (глубокую) иерархию классов, то использование Custom Managed Records для их обёртывания, вероятно, не для вас.

К счастью, библиотека Skia использует очень плоскую иерархию классов, что делает её идеальной для обёртывания с помощью Custom Managed Records. Есть несколько унаследованных классов, но они встречаются нечасто. (Для таких случаев я создал подкласс «record» как запись с одним полем базового типа записи. Это, опять же, некрасиво, но, к счастью, встречается нечасто.)

К счастью, многие современные API отказываются от глубоких иерархий классов в пользу более современного подхода «композиция вместо наследования». Такие подходы идеально подходят для обёртывания с помощью Custom Managed Records.

## Попробуйте

Так что, если вам когда-нибудь понадобится создать оболочку для C API, рассмотрите возможность использования Custom Managed Records. Если API соответствует этой модели, то, на мой взгляд, это очень элегантный и лёгкий подход к представлению API в удобном для пользователя виде.
